<?xml version="1.0" encoding="utf-8" ?>

<!DOCTYPE rfc SYSTEM "rfc2629.dtd">

<rfc ipr="trust200902"
     docName="draft-sctl-hybrid-split-00"
     category="std">

  <?rfc toc="yes"?> <?rfc symrefs="yes"?> <?rfc autobreaks="yes"?>
  <?rfc tocindent="yes"?> <?rfc compact="yes"?> <?rfc subcompact="no"?>

  <front>
    <title abbrev="Discovery Proxy Split">A Split Model for Multicast Discovery Proxy</title>

    <author initials='S.' surname='Cheshire' fullname='Stuart Cheshire'>
      <organization>Apple Inc.</organization>
      <address>
	<postal>
          <street>1 Infinite Loop</street>
          <city>Cupertino</city>
          <region>California</region>
          <code>95014</code>
          <country>USA</country>
	</postal>
	<phone>+1 408 974 3207</phone>
	<email>cheshire@apple.com</email>
      </address>
    </author>

    <author initials="T" surname="Lemon" fullname="Ted Lemon">
      <organization>Nominum, Inc.</organization>
      <address>
	<postal>
	  <street>800 Bridge Parkway</street>
	  <city>Redwood City</city>
	  <region>California</region>
	  <country>United States of America</country>
	  <code>94065</code>
	</postal>
	<phone>+1 650 381 6000</phone>
	<email>ted.lemon@nominum.com</email>
      </address>
    </author>

    <date month="April" year="2017" />

    <abstract>
      <t>
	This document extends the Multicast Service Discovery Proxy specification by splitting
	the Discovery Proxy into two seperable modules, one of which is lightweight and
	stateless, while the other manages all necessary state and need not be present on every
	link.
      </t>
    </abstract>
  </front>

  <middle>
    <section anchor="intro" title="Introduction">
      <t>
	The Multicast Service Discovery Proxy <xref target="I-D.ietf-dnssd-hybrid"/>
	specification defines a mechanism for discovering services on a subnetted network using
	Multicast DNS (mDNS) <xref target="RFC6762"/>, through the use of Discovery Proxies,
	which issue mDNS requests on various links in the network on behalf of a host attempting
	service discovery.
      </t>
      <t>
	The original Discovery Proxy is specified as a single service, instances of which are
	present on every link in a particular network.   When a client wishes to enumerate all
	services of a particular type, it first queries for a list of "browsing domains," and
	then queries for the particular service it wants, asking the same question in each of
	the browsing domains.
      </t>
      <t>
	In practice, for a host that is relying on a caching resolver, this means that a
	sequence of queries will arrive at the caching resolver, all nearly identical, one for
	each of the the set of browsing domains, of which there will be one per link.  Each of
	the browsing domains has to be at least notionally a separate zone, because each domain
	is served by a different server.
      </t>
      <t>
	Some of the practical implications of this are that each hybrid proxy has to have a
	complete configuration that allows it to do data translation (see Multicast Service
	Discovery Proxy <xref target="I-D.ietf-dnssd-hybrid"/> section 5.5).   The local
	caching resolver must support DNS Push, or that functionality is lost.   Supporting
	DNS push in a general-purpose caching resolver adds complexity that in most cases
	is not needed.
      </t>
      <t>
	This document proposes a new architecture in which the Discovery Proxy is simplified, and
	the caching server takes over part of the work of the Discovery Proxy, and is customized
	to suit the specific needs of multi-link service discovery.   The Discovery Proxy is
	split into two separable modules:
	<list style="hanging">
	  <t hangText="Query Proxy">
	    which is a stateful proxy that answers queries from clients and issues queries to
	    Relay Proxies.  Any DNSSD installation must have at least one Query Proxy.
	  </t>
	  <t hangText="Relay Proxy">
	    which is a stateless proxy that asks questions posed by Query Proxies on a link
	    and returns responses to such questions to the Query Proxy.  Exactly one query
	    proxy is required for each link on which service discovery will be supported.
	  </t>
	</list>
      </t>
    </section>

    <section anchor="qproxy" title="Query Proxy">
      <t>
	The Query proxy performs queries on behalf of hosts.  Hosts can both enumerate and use
	services.  When a host asks to enumerate a service, the Query Proxy will query Relay
	Proxies on every local link to provide a set of answers to the host.  When a host asks
	to use a service, the Query Proxy will issue its query only on the link on which that
	service is known to exist. [what if it's been forgotten?]
      </t>
      <t>
	The Query Proxy also receives sleep proxy requests and service announcements that
	are relayed by Relay Proxies. [hm]
      </t>
      <t>
	The Query Proxy maintains a cache which contains:
	<list style="symbols">
	  <t>proactive registrations from services on local links</t>
	  <t>cached results of previous queries that have not yet timed out</t>
	  <t>sleep proxy registrations</t>
	</list>
      </t>
      <t>
	All responses from relay proxies are cached for a period of 'INTERVAL' or the TTL of the
	response, whichever is shorter [?].
      </t>
      <t>
	When a host has requested DNS push, or has issued a "use" query, any answers available
	in the cache are returned immediately.  If a host requests enumeration of a service type,
	and does not request DNS push, the Query Proxy waits for 'INTERVAL' and then composes
	an answer using whatever information is present in the cache, which will include any
	answers that have come in from the relay proxy during the wait.
      </t>
      <t>
	The Query Proxy performs data translation, as described in Multicast Service Discovery
	Hybrid section 5.5 <xref target="I-D.ietf-dnssd-hybrid"/>.
      </t>
      <section anchor="qp-listen" title="Query Proxy Listener Configuration">
	<t>
	  The Query Proxy may be implemented as a standalone DNS server that is authoritative
	  for the local zones, or may be embedded in a DNS Proxy <xref target="RFC5625"/> or
	  caching resolver.   How this is done depends on the context in which the Query Proxy
	  is being used: in a campus network with knowledgable operators, it may make sense
	  for the Query Proxy to be a simple authoritative server answering queries on port
	  53.
	</t>
	<t>
	  In a homenet <xref target="RFC7368"/>, it may be necessary to have a dedicated DNS
	  resolver or proxy co-located in the same homenet router as the Query Proxy.  In
	  this case, the two services will have to share port 53, or else the Query Proxy will
	  have to listen on a dedicated IP address.   The caching resolver or proxy will
	  have to know to direct queries for local domains to the query proxy, and not to
	  the ISP-provided caching resolver or to authoritative servers on the Internet.
	</t>
	<t>
	  If the local domains exist in the global namespace, no special configuration is
	  required beyond what is described in DNS Service Discovery <xref target="RFC6763"/>.
	  However, in some environments, for example the homenet environment, the local domains
	  are in non-unique, locally-served namespaces.  These cannot be delegated in the global
	  DNS, which means that hosts that are to access services enumerated in these zones
	  must use a resolver that answers with the locally-served names.
	</t>
	<t>
	  It may also be the case that even though the local domains exist in the global
	  namespace, the Query Proxy is configured not to answer queries from outside of the
	  campus network, so that if a caching resolver off of the campus network is queried,
	  no services can be discovered.
	</t>
	<t>
	  Consequently, hosts that intend to discover services must use the resolver that is
	  offered by the local network, e.g. with DHCPv4 <xref target="RFC2132"/>, DHCPv6 <xref
	  target="RFC3646"/> or through the RDNSS option <xref target="RFC6106"/> delivered in a
	  router advertisement <xref target="RFC4861"/>.  Hosts that override the
	  locally-provided DNS caching resolver risk being unable to discover services on the
	  local network.
	</t>
      </section>
      <section anchor="qp-service" title="Authoritative Service">
	<t>
	  The Query Proxy is functionally an authoritative server for all local zones.  It may
	  or may not provide the full services of a local authoritative server.  For example, an
	  authoritative server for a zone is expected to provide an SOA record for the zone and
	  to provide a strictly increasing serial number <xref target="RFC1982"/> which
	  increases each time the content of the zone changes.   Query Proxies may or may not
	  provide such a service.
	</t>
	<t>
	  Authoritative servers also generally provide notify and zone transfer service for
	  secondary DNS servers.   Such services allow for secondary DNS service to be provided.
	  However, secondary service requires that the zone contents be completely known;
	  the Multicast Discovery Proxy does not know the full set of names in a zone, so if
	  secondary service were provided, the contents of the zone would be incomplete, and
	  service discovery could not succeed through the secondary server.
	</t>
	<t>
	  An additional characteristic of authoritative servers is that it is expected to be the
	  case a caching resolver may cache the content of that record for the duration of its
	  TTL and respond directly to a query for it without consulting the authoritative
	  server.  Similarly, an NXDOMAIN may be cached for some period of time, typically the
	  TTL of the zone.  This is discussed in section 5.5.1 of <xref target="I-D.ietf-dnssd-hybrid"/>.
	</t>
      </section>
      <section anchor="qp-cache" title="Multicast Resolution Process">
	<t>
	  The Query Proxy maintains a cache of answers that it has received from services on
	  the local network.   This cache is updated whenever new data is received from the
	  network.   Cache entries have lifetimes as specified in the TTLs of the answers that
	  are received for mDNS queries done on local links: when a new entry is added to the
	  cache, it is marked for expiration at the current time plus the TTL [refresh time?].
	  At expiration, the entry is removed from the cache.
	</t>
	<t>
	  When a host asks a question, the Query Proxy begins a Multicast Resolution process
	  for that question. ...
	</t>
	<t>
	  The question is then answered out of the cache.  If the host requests DNS Push service
	  <xref target="I-D.ietf-dnssd-push"/>, answers are provided immediately for any information
	  that is already in the cache; as new entries are added to the cache, these entries are
	  pushed to the client as long as the DNS push session for that query remains valid.
	</t>
	<t>
	  If a host did not request DNS push, the Query Proxy sets a timer for QUERYWAIT seconds
	  and awaits results from the multicast resolution process.   When the timer has expired,
	  the Query Proxy answers the question using whatever information is available in the
	  cache at that time.
	</t>
      </section>	  
    </section>

    <section anchor="rproxy" title="Relay Proxy">
      <t>
	Relay proxies are essentially stateless, although they must be configured with the
	IP Address of a Query Proxy to which bonjour sleep proxy requests and mDNS service
	announcements [term?] can be sent.
      </t>
      <t>
	Relay proxies listen for DNS queries as in section 4.2 of <xref target="RFC1034"/>.
	Queries are tagged with EDNS0 option 'TBD' to indicate the set of links on which the
	query is to be relayed. [this is an open item, could also use different ports, or
	derive link name from query and send a query for every link, but this requires
	proxies to know link names.]
      </t>
      <t>
	The Relay Proxy retransmits any question received from the Query Proxy on the specified
	link or links using Multicast DNS <xref target="RFC6762"/>.  Responses to the question
	are then forwarded back to the Query Proxy, tagged with the link through which the
	response was received using EDNS0 option 'TBD'.  [or port, or link name, see previous
	paragraph.]
      </t>
      <t>
	The Query Proxy MUST enable DNS Push.   The Hybrid Proxy returns answers using the DNS
	Push session in which the question was asked.   Questions asked outside of a DNS Push
	session are answered with a result code of REFUSED.
      </t>
    </section>

    <section anchor="security" title="Security Considerations">
    </section>

    <section title="IANA Considerations">
    </section>

    <section title="Acknowledgments">
    </section>

  </middle>

  <back>

    <references title="Normative References">
      <?rfc include="reference.RFC.1034.xml"?>
      <?rfc include="reference.RFC.6762.xml"?>
      <?rfc include="reference.RFC.5625"?>
      <?rfc include="reference.RFC.7368"?>
      <?rfc include="reference.RFC.2132"?>
      <?rfc include="reference.RFC.4861"?>
      <?rfc include="reference.I-D.ietf-dnssd-hybrid"?>
      <?rfc include="reference.I-D.ietf-dnssd-push"?>
      <?rfc include="reference.RFC.3646"?>
      <?rfc include="reference.RFC.6763"?>
      <?rfc include="reference.RFC.6106"?>
      <?rfc include="reference.RFC.1982"?>
    </references>

    <references title="Informative References">
      <?rfc include="reference.RFC.1035.xml"?>
    </references>
  </back>
</rfc>
