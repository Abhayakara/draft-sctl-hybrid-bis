<?xml version="1.0" encoding="utf-8" ?>

<!DOCTYPE rfc SYSTEM "rfc2629.dtd">

<rfc ipr="trust200902"
     docName="draft-sctl-hybrid-split-00"
     category="std">

  <?rfc toc="yes"?> <?rfc symrefs="yes"?> <?rfc autobreaks="yes"?>
  <?rfc tocindent="yes"?> <?rfc compact="yes"?> <?rfc subcompact="no"?>

  <front>
    <title abbrev="Discovery Proxy Split">A Split Model for Multicast Discovery Proxy</title>

    <author initials='S.' surname='Cheshire' fullname='Stuart Cheshire'>
      <organization>Apple Inc.</organization>
      <address>
	<postal>
          <street>1 Infinite Loop</street>
          <city>Cupertino</city>
          <region>California</region>
          <code>95014</code>
          <country>USA</country>
	</postal>
	<phone>+1 408 974 3207</phone>
	<email>cheshire@apple.com</email>
      </address>
    </author>

    <author initials="T" surname="Lemon" fullname="Ted Lemon">
      <organization>Nominum, Inc.</organization>
      <address>
	<postal>
	  <street>800 Bridge Parkway</street>
	  <city>Redwood City</city>
	  <region>California</region>
	  <country>United States of America</country>
	  <code>94065</code>
	</postal>
	<phone>+1 650 381 6000</phone>
	<email>ted.lemon@nominum.com</email>
      </address>
    </author>

    <date month="April" year="2017" />

    <abstract>
      <t>
	This document extends the Multicast Service Discovery Proxy specification by splitting
	the Discovery Proxy into two seperable modules, one of which is lightweight and
	stateless, while the other manages all necessary state and need not be present on every
	link.
      </t>
    </abstract>
  </front>

  <middle>
    <section anchor="intro" title="Introduction">
      <t>
	The Multicast Service Discovery Proxy <xref target="I-D.ietf-dnssd-hybrid"/>
	specification defines a mechanism for discovering services on a subnetted network using
	Multicast DNS (mDNS) <xref target="RFC6762"/>, through the use of Discovery Proxies,
	which issue mDNS requests on various links in the network on behalf of a host attempting
	service discovery.
      </t>
      <t>
	The original Discovery Proxy is specified as a single service, instances of which are
	present on every link in a particular network.   When a client wishes to enumerate all
	services of a particular type, it first queries for a list of "browsing domains," and
	then queries for the particular service it wants, asking the same question in each of
	the browsing domains.
      </t>
      <t>
	In practice, for a host that is relying on a caching resolver, this means that a
	sequence of queries will arrive at the caching resolver, all nearly identical, one for
	each of the the set of browsing domains, of which there will be one per link.  Each of
	the browsing domains has to be at least notionally a separate zone, because each domain
	is served by a different server.
      </t>
      <t>
	Some of the practical implications of this are that each hybrid proxy has to have a
	complete configuration that allows it to do data translation (see Multicast Service
	Discovery Proxy <xref target="I-D.ietf-dnssd-hybrid"> section 5.5).   The local
	caching resolver must support DNS Push, or that functionality is lost.   Supporting
	DNS push in a general-purpose caching resolver adds complexity that in most cases
	is not needed.
      </t>
      <t>
	This document proposes a new architecture in which the Discovery Proxy is simplified, and
	the caching server takes over part of the work of the Discovery Proxy, and is customized
	to suit the specific needs of multi-link service discovery.   The Discovery Proxy is
	split into two separable modules:
	<list style="hanging">
	  <t hangText="Query Proxy">
	    which is a stateful proxy that answers queries from clients and issues queries to
	    Relay Proxies.  Any DNSSD installation must have at least one Query Proxy.
	  </t>
	  <t hangText="Relay Proxy">
	    which is a stateless proxy that asks questions posed by Query Proxies on a link
	    and returns responses to such questions to the Query Proxy.  Exactly one query
	    proxy is required for each link on which service discovery will be supported.
	  </t>
	</list>
      </t>
    </section>

    <section anchor="qproxy" title="Query Proxy">
      <t>
	The Query proxy performs queries on behalf of hosts.  Hosts can both enumerate and use
	services.  When a host asks to enumerate a service, the Query Proxy will query Relay
	Proxies on every local link to provide a set of answers to the host.  When a host asks
	to use a service, the Query Proxy will issue its query only on the link on which that
	service is known to exist. [what if it's been forgotten?]
      </t>
      <t>
	The Query Proxy also receives sleep proxy requests and service announcements that
	are relayed by Relay Proxies. [hm]
      </t>
      <t>
	The Query Proxy maintains a cache which contains:
	<list style="symbols">
	  <t>proactive registrations from services on local links</t>
	  <t>cached results of previous queries that have not yet timed out</t>
	  <t>sleep proxy registrations</t>
	</list>
      </t>
      <t>
	All responses from relay proxies are cached for a period of 'INTERVAL' or the TTL of the
	response, whichever is shorter [?].
      </t>
      <t>
	When a host has requested DNS push, or has issued a "use" query, any answers available
	in the cache are returned immediately.  If a host requests enumeration of a service type,
	and does not request DNS push, the Query Proxy waits for 'INTERVAL' and then composes
	an answer using whatever information is present in the cache, which will include any
	answers that have come in from the relay proxy during the wait.
      </t>
      <t>
	The Query Proxy performs data translation, as described in Multicast Service Discovery
	Hybrid section 5.5 <xref target="I-D.ietf-dnssd-hybrid"/>.
      </t>
    </section>

    <section anchor="rproxy" title="Relay Proxy">
      <t>
	Relay proxies are essentially stateless, although they must be configured with the
	IP Address of a Query Proxy to which bonjour sleep proxy requests and mDNS service
	announcements [term?] can be sent.
      </t>
      <t>
	Relay proxies listen for DNS queries as in section 4.2 of <xref target="RFC1034"/>.
	Queries are tagged with EDNS0 option 'TBD' to indicate the set of links on which the
	query is to be relayed. [this is an open item, could also use different ports, or
	derive link name from query and send a query for every link, but this requires
	proxies to know link names.]
      </t>
      <t>
	The Relay Proxy retransmits any question received from the Query Proxy on the specified
	link or links using Multicast DNS <xref target="RFC6762"/>.  Responses to the question
	are then forwarded back to the Query Proxy, tagged with the link through which the
	response was received using EDNS0 option 'TBD'.  [or port, or link name, see previous
	paragraph.]
      </t>
      <t>
	The Query Proxy MUST enable DNS Push.   The Hybrid Proxy returns answers using the DNS
	Push session in which the question was asked.   Questions asked outside of a DNS Push
	session are answered with a result code of REFUSED.
      </t>
    </section>

    <section anchor="security" title="Security Considerations">
    </section>

    <section title="IANA Considerations">
    </section>

    <section title="Acknowledgments">
    </section>

  </middle>

  <back>

    <references title="Normative References">
      <?rfc include="reference.RFC.1034.xml"?>
      <?rfc include="reference.RFC.6762.xml"?>
      <?rfc include="reference.RFC.6763.xml"?>
      <?rfc include="reference.I-D.ietf-dnssd-hybrid"?>
      <reference anchor="SLEEP"
		 target="https://www.torproject.org">
	<front>
	  <title>Bonjour Sleep Proxy</title>

	  <author>
	    <organization>Apple Computer, Inc.</organization>
	  </author>
	  <date year="unknown"/>
	</front>
      </reference>
    </references>

    <references title="Informative References">
      <?rfc include="reference.RFC.1035.xml"?>
    </references>
  </back>
</rfc>
