<?xml version="1.0" encoding="utf-8" ?>

<!DOCTYPE rfc SYSTEM "rfc2629.dtd">

<rfc ipr="trust200902"
     docName="draft-sctl-hybrid-bis-00"
     category="std">

  <?rfc toc="yes"?> <?rfc symrefs="yes"?> <?rfc autobreaks="yes"?>
  <?rfc tocindent="yes"?> <?rfc compact="yes"?> <?rfc subcompact="no"?>

  <front>
    <title abbrev="dnssd-hybrid-bis">Extensions to DNSSD Discovery Proxy</title>

    <author initials='S.' surname='Cheshire' fullname='Stuart Cheshire'>
      <organization>Apple Inc.</organization>
      <address>
	<postal>
          <street>1 Infinite Loop</street>
          <city>Cupertino</city>
          <region>California</region>
          <code>95014</code>
          <country>USA</country>
	</postal>
	<phone>+1 408 974 3207</phone>
	<email>cheshire@apple.com</email>
      </address>
    </author>

    <author initials="T" surname="Lemon" fullname="Ted Lemon">
      <organization>Nominum, Inc.</organization>
      <address>
	<postal>
	  <street>800 Bridge Parkway</street>
	  <city>Redwood City</city>
	  <region>California</region>
	  <country>United States of America</country>
	  <code>94065</code>
	</postal>
	<phone>+1 650 381 6000</phone>
	<email>ted.lemon@nominum.com</email>
      </address>
    </author>

    <date month="April" year="2017" />

    <abstract>
      <t>
	This document extends the Multicast Service Discovery Proxy specification by splitting
	the Discovery Proxy into two seperable modules, one of which is lightweight and
	stateless, while the other manages all necessary state and need not be present on every
	link.  This document additionally defines a mode of service advertising where the
	service proactively registers itself with the network rather than having to be
	discovered.
      </t>
    </abstract>
  </front>

  <middle>
    <section anchor="intro" title="Introduction">
      <t>
	The Multicast Service Discovery Proxy <xref target="I-D.ietf-dnssd-hybrid"/>
	specification defines a mechanism for discovering services on a subnetted network using
	mDNS, through the use of Discovery Proxies, which issue mDNS requests on various links
	in the network on behalf of a host attempting service discovery.
      </t>
      <t>
	This document extends the Multicast Service Discovery Proxy in several ways:
	<list style="symbols">
	  <t>
	    Split the Discovery Proxy into two separable modules:
	    <list style="hanging">
	      <t hangText="Query Proxy">
		which is a stateful proxy that answers queries from clients and issues queries to
		Relay Proxies.  Any DNSSD installation must have at least one Query Proxy.
	      </t>
	      <t hangText="Relay Proxy">
		which is a stateless proxy that asks questions posed by Query Proxies on a link
		and returns responses to such questions to the Query Proxy.  Exactly one query
		proxy is required for each link on which service discovery will be supported.
	      </t>
	    </list>
	  </t>
	  <t>
	    Provide a mechanism whereby a DNSSD service can advertise services proactively,
	    instead of requiring that a service be discovered.
	  </t>
	  <t>
	    Provide a means whereby such a service can claim ownership of a particular service
	    name for a period of time, without that service necessarily being advertised as
	    available.
	  </t>
	  <t>
	    Provide a means whereby such a service can have its information published by the
	    Query Proxy even when it is not sensitive to network requests.
	  </t>
	  <t>
	    Provide a means of waking up such a service when a request is made, using a
	    'wake-on-lan packet'.
	  </t>
	  <t>
	    Act as a bonjour sleep proxy, making this service available to existing hosts that
	    support sleep proxy <xref target="SLEEP"/>.
	  </t>
	</list>	  
      </t>
    </section>
    <section anchor="qtype" title="Query Types">
      <t>[Is this already in a document somewhere, e.g. RFC 6763?]</t>
      <t>
	Bonjour [ref] originally provided three primitives:
	<list style="hanging">
	  <t hangText="register">advertise a service</t>
	  <t hangText="browse">discover services</t>
	  <t hangText="resolve">get IP address and port for a service</t>
	</list>
      </t>
      <t>
	We clarify this as follows: Offer, Enumerate, Use.
	<list style="hanging">
	  <t hangText="Offer">
	    A server indicates what service type it provides, under what instance name.
	    [what do these look like?]
	  </t>
	  <t hangText="Enumerate">
	    A potential client requests a list of available instances for a specified desired service type.
	    [what do these look like?]
	  </t>
	  <t hangText="Use">
	    Having picked a particular instance to use, a client then wants to use it. The
	    relevant difference here is we are talking in terms of a connect-by-name style of
	    API. Whereas “resolve” reveals IP addresses to client software, the “use” API takes
	    a named instance as input, and returns a connection to that service. Client software
	    does not need to get involved with IP addresses, Happy Eyeballs, etc.
	    [what do these look like?]
	  </t>
	</list>
	[What about the other primitives implied by list in intro?]
      </t>
    </section>
    <section anchor="qproxy" title="Query Proxy">
      <t>
	The Query proxy performs queries on behalf of hosts.  Hosts can both enumerate and use
	services.  When a host asks to enumerate a service, the Query Proxy will query Relay
	Proxies on every local link to provide a set of answers to the host.  When a host asks
	to use a service, the Query Proxy will issue its query only on the link on which that
	service is known to exist. [what if it's been forgotten?]
      </t>
      <t>
	The Query Proxy also receives sleep proxy requests and service announcements that
	are relayed by Relay Proxies. [hm]
      </t>
      <t>
	The Query Proxy maintains a cache which contains:
	<list style="symbols">
	  <t>proactive registrations from services on local links</t>
	  <t>cached results of previous queries that have not yet timed out</t>
	  <t>sleep proxy registrations</t>
	</list>
      </t>
      <t>
	All responses from relay proxies are cached for a period of 'INTERVAL' or the TTL of the
	response, whichever is shorter [?].
      </t>
      <t>
	When a host has requested DNS push, or has issued a "use" query, any answers available
	in the cache are returned immediately.  If a host requests enumeration of a service type,
	and does not request DNS push, the Query Proxy waits for 'INTERVAL' and then composes
	an answer using whatever information is present in the cache, which will include any
	answers that have come in from the relay proxy during the wait.
      </t>
      <t>
	The Query Proxy performs data translation, as described in Multicast Service Discovery
	Hybrid section 5.5 <xref target="I-D.ietf-dnssd-hybrid"/>.
      </t>
    </section>

    <section anchor="rproxy" title="Relay Proxy">
      <t>
	Relay proxies are essentially stateless, although they must be configured with the
	IP Address of a Query Proxy to which bonjour sleep proxy requests and mDNS service
	announcements [term?] can be sent.
      </t>
      <t>
	Relay proxies listen for DNS queries as in section 4.2 of <xref target="RFC1034"/>.
	Queries are tagged with EDNS0 option 'TBD' to indicate the set of links on which the
	query is to be relayed. [this is an open item, could also use different ports, or
	derive link name from query and send a query for every link, but this requires
	proxies to know link names.]
      </t>
      <t>
	The Relay Proxy retransmits any question received from the Query Proxy on the specified
	link or links using Multicast DNS <xref target="RFC6762"/>.  Responses to the question
	are then forwarded back to the Query Proxy, tagged with the link through which the
	response was received using EDNS0 option 'TBD'.  [or port, or link name, see previous
	paragraph.]
      </t>
      <t>
	The Query Proxy MUST enable DNS Push.   The Hybrid Proxy returns answers using the DNS
	Push session in which the question was asked.   Questions asked outside of a DNS Push
	session are answered with a result code of REFUSED.
      </t>
    </section>

    <section anchor="security" title="Security Considerations">
    </section>

    <section title="IANA Considerations">
    </section>

    <section title="Acknowledgments">
    </section>

  </middle>

  <back>

    <references title="Normative References">
      <?rfc include="reference.RFC.1034.xml"?>
      <?rfc include="reference.RFC.6762.xml"?>
      <?rfc include="reference.RFC.6763.xml"?>
      <?rfc include="reference.I-D.ietf-dnssd-hybrid"?>
      <reference anchor="SLEEP"
		 target="https://www.torproject.org">
	<front>
	  <title>Bonjour Sleep Proxy</title>

	  <author>
	    <organization>Apple Computer, Inc.</organization>
	  </author>
	  <date year="unknown"/>
	</front>
      </reference>
    </references>

    <references title="Informative References">
      <?rfc include="reference.RFC.1035.xml"?>
    </references>
  </back>
</rfc>
